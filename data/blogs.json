[
  {
    "title": "LeetCode",
    "content": [
    "<h2>Giới thiệu</h2>\n",
    "<p>Lý do mình bắt đầu học LeetCode là muốn cải thiện kỹ năng code, thích giải đố và có một người chú làm trong lĩnh vực AI khuyên nhủ. Ban đầu mình khá bỡ ngỡ và có phần lo lắng.</p>\n",
    "\n<h2>Khởi đầu</h2>\n<p>Những ngày đầu rất khó khăn: chưa quen cách đọc đề, vốn tiếng Anh hạn chế và chưa biết đến các dạng form chuẩn. Ngay cả những bài <strong>Easy</strong> như <em>Two Sum</em>, <em>Valid Parentheses</em> cũng làm mình tốn nhiều thời gian.</p><img src='images/LeetCode1.png' alt='Quá trình luyện tập'>\n", 
    "\n<h2>Quá trình luyện tập</h2>\n<p>Mỗi ngày mình đặt mục tiêu giải ít nhất 1 bài. Khi có thời gian rảnh và tinh thần thoải mái hơn, mình có thể làm từ 4–6 bài. Ngoài ra, mình thường xuyên dành thời gian để <strong>review lại code</strong>. Những chủ đề cơ bản mình học ban đầu gồm: <strong>Array</strong>, <strong>HashMap</strong>, <strong>Two Pointers</strong>, và <strong>Linked List</strong>.</p>\n\n<h2>Khó khăn và cách vượt qua</h2>\n<p>Ban đầu rất khó để duy trì thói quen luyện tập, nhiều lúc cảm thấy nản và phải xem code mẫu của người khác hoặc dùng các công cụ hỗ trợ. Cách mình vượt qua là xem lời giải mẫu rồi tự viết lại theo cách hiểu của mình, sau đó làm thêm các bài tương tự trong cùng chủ đề. Quan trọng nhất là giữ vững tinh thần, không bỏ cuộc: mỗi ngày cố gắng giải hoặc review ít nhất một bài.</p>\n\n<h2>Thành quả</h2>\n<p>Sau khoảng 1 tháng, mình đã giải được hơn 40 bài Easy và có thể làm được 1–2 bài Medium. Sau khoảng 100 bài Easy, mình bắt đầu giải Medium tự tin hơn, và đến khi giải được 140 bài Easy thì chuyển hẳn sang Medium. Đến nay, mình đã giải hơn 100 bài Medium. Việc luyện tập trên LeetCode giúp mình nâng cao tư duy thuật toán, hiểu bài học trên lớp dễ hơn và không còn lúng túng khi xem các video phỏng vấn giải thuật.</p>\n",
    "<img src='images/LeetCode2.png'> \n<h2>Lời khuyên cho người mới</h2>\n",
    "<p>Điều quan trọng nhất là <strong>không bỏ cuộc</strong>. Hãy coi mỗi bài giải được là một niềm vui nhỏ. Cảm giác thành tựu sẽ tiếp thêm động lực để bạn đi xa hơn. Khi nhìn lại, bạn sẽ bất ngờ vì chặng đường mình đã đi qua.</p>\n\n<h2>Kết luận</h2>\n<p>Tóm lại, hành trình luyện tập trên LeetCode không dễ dàng nhưng rất đáng giá. Chỉ cần kiên trì và giữ thói quen mỗi ngày, bạn sẽ đạt được tiến bộ đáng kể.</p>"
    ]
  },
  {
    "title": "HanwhaLife Financial Mentor",
    "content": ["<h2>Giới thiệu</h2>\n<p>Mình tham gia chương trình <strong>HanwhaLife Financial Mentor</strong> vì cơ hội nhận học bổng bằng tiền mặt và đặc biệt là phần thưởng hấp dẫn – một chuyến đi trải nghiệm tại Hàn Quốc. Đây cũng là cơ hội hiếm có để mở rộng tầm nhìn về ngành tài chính – bảo hiểm và kết nối với nhiều bạn trẻ có cùng đam mê.</p>\n", 
    "<img src='images/HL4.png'>",
    "\n<h2>Kỳ vọng và Ấn tượng ban đầu</h2>\n<p>Ngay từ đầu, mình đã kỳ vọng có thể giành được suất học bổng giá trị và mong muốn được đặt chân ra nước ngoài lần đầu tiên. Ấn tượng ban đầu về chương trình là sự chuyên nghiệp, quy mô và tính cạnh tranh khá cao, khiến mình vừa hào hứng vừa hồi hộp.</p>\n", 
    "\n<h2>Quá trình tham gia</h2>\n<p>Để tiến xa trong chương trình, mình phải trải qua nhiều vòng xét duyệt: từ kiểm tra <strong>GPA</strong>, phỏng vấn tiếng Anh, cho đến kiểm tra kiến thức tài chính. Mỗi vòng đều mang đến thách thức mới, đòi hỏi sự chuẩn bị kỹ càng và tinh thần bền bỉ. Mình đã phải học hỏi thêm về đầu tư, bảo hiểm và cả cách quản lý tài chính cá nhân.</p>\n", 
    "<img src='images/HL2.png'>",
    "\n<h2>Khó khăn và Bài học</h2>\n<p>Một trong những khó khăn lớn nhất là làm việc cùng những người giỏi hơn mình. Ban đầu mình thấy áp lực và phải nỗ lực rất nhiều để bắt kịp tiến độ của mọi người. Thêm vào đó, kiến thức về tài chính của mình còn hạn chế nên phải dành nhiều thời gian tự học thêm.</p>\n<p>Nhưng chính nhờ vậy, mình học được cách <strong>làm việc nhóm hiệu quả</strong>, mở rộng hiểu biết về đầu tư, bảo hiểm và nhận thức rõ hơn về <strong>trách nhiệm xã hội</strong> của các doanh nghiệp. Đây là những bài học quý giá không chỉ cho chương trình mà còn cho hành trình phát triển bản thân sau này.</p>\n", 
    "\n<h2>Thành quả</h2>\n<p>Dù chưa biết mình có được đặt chân đến Hàn Quốc hay không, nhưng việc đi đến gần cuối chặng đường của chương trình đã là một thành quả lớn. Mình đã nhận được một phần học bổng từ những vòng trước, gặp gỡ và kết nối được với nhiều người bạn mới, và quan trọng hơn là bản thân trưởng thành hơn qua mỗi thử thách.</p>\n", 
    "<img src='images/HL3.png'>",
    "\n<h2>Lời khuyên và Cảm nhận</h2>\n<p>Chương trình này thật sự là một thử thách không nhỏ, đặc biệt khi phải cân bằng giữa việc học ở trường và các hoạt động của chương trình. Mặc dù có đôi lúc chương trình gặp vấn đề như thay đổi lịch trình, mình vẫn cảm thấy may mắn vì đã tham gia. Hy vọng trong tương lai sẽ có thêm những cơ hội rõ ràng và ổn định hơn, và khi đó mình sẽ đủ trưởng thành để chinh phục chúng một cách trọn vẹn.</p>"
    ]
  },

  {
  "title": "Java Basics",
  "content": [
    "<h2>Giới thiệu</h2>",
    "<p>Java là một ngôn ngữ lập trình phổ biến, hướng đối tượng, mạnh mẽ và dễ bảo trì. Bài viết này sẽ giới thiệu những khái niệm cơ bản, giúp bạn làm quen với Java nếu mới bắt đầu.</p>",
    
    "<h2>Biến và kiểu dữ liệu</h2>",
    "<p>Trong Java, mọi dữ liệu đều phải có kiểu. Một số kiểu dữ liệu cơ bản:</p>",
    "<ul>",
    "<li><strong>int</strong>: số nguyên</li>",
    "<li><strong>double</strong>: số thực</li>",
    "<li><strong>boolean</strong>: true hoặc false</li>",
    "<li><strong>char</strong>: ký tự</li>",
    "<li><strong>String</strong>: chuỗi ký tự</li>",
    "</ul>",
    "<p>Ví dụ khai báo biến:</p>",
    "<pre>int age = 20;\nString name = \"Duy\";\nboolean isStudent = true;</pre>",

    "<h2>Toán tử</h2>",
    "<p>Java hỗ trợ toán tử số học (+, -, *, /, %), toán tử so sánh (==, !=, &lt;, &gt;, &lt;=, &gt;=) và toán tử logic (&&, ||, !).</p>",
    "<p>Ví dụ:</p>",
    "<pre>int a = 5;\nint b = 3;\nboolean result = (a &gt; b) && (b &lt; 10); // true</pre>",

    "<h2>Vòng lặp</h2>",
    "<p>Vòng lặp giúp lặp đi lặp lại các đoạn code:</p>",
    "<ul>",
    "<li><strong>for</strong>: lặp số lần xác định</li>",
    "<li><strong>while</strong>: lặp khi điều kiện đúng</li>",
    "<li><strong>do-while</strong>: lặp ít nhất một lần</li>",
    "</ul>",
    "<p>Ví dụ:</p>",
    "<pre>for(int i = 0; i &lt; 5; i++) {\n    System.out.println(i);\n}</pre>",

    "<h2>Câu lệnh điều kiện</h2>",
    "<p>Java dùng <strong>if-else</strong> để kiểm tra điều kiện:</p>",
    "<pre>int score = 85;\nif(score &gt;= 90) {\n    System.out.println(\"Xuất sắc\");\n} else if(score &gt;= 70) {\n    System.out.println(\"Khá\");\n} else {\n    System.out.println(\"Cần cố gắng\");\n}</pre>",

    "<h2>Hàm / Method</h2>",
    "<p>Hàm (method) giúp tái sử dụng code:</p>",
    "<pre>public static int sum(int a, int b) {\n    return a + b;\n}\n\nint result = sum(5, 3); // 8</pre>",

    "<h2>Kết luận</h2>",
    "<p>Những kiến thức cơ bản này là nền tảng để bạn học các chủ đề nâng cao trong Java như OOP, Collections hay Streams. Hãy thử viết các chương trình nhỏ để luyện tập và ghi nhớ cách sử dụng biến, toán tử, vòng lặp và hàm.</p>"
  ]
},

{
  "title": "OOP trong Java",
  "content": [
    "<h2>Giới thiệu</h2>",
    "<p>Lập trình hướng đối tượng (OOP) là phương pháp tổ chức code thành các đối tượng, giúp dễ quản lý, mở rộng và tái sử dụng. Java là ngôn ngữ hướng đối tượng hoàn toàn, nên hiểu OOP là điều cần thiết.</p>",

    "<h2>Class và Object</h2>",
    "<p>Class là khuôn mẫu để tạo đối tượng (object). Object là thực thể của class.</p>",
    "<p>Ví dụ:</p>",
    "<pre>public class Person {\n    String name;\n    int age;\n\n    void sayHello() {\n        System.out.println(\"Hello, my name is \" + name);\n    }\n}\n\nPerson p = new Person();\np.name = \"Duy\";\np.age = 20;\np.sayHello();</pre>",

    "<h2>Encapsulation (Đóng gói)</h2>",
    "<p>Ẩn dữ liệu bằng <strong>private</strong> và cung cấp <strong>getter/setter</strong> để truy cập.</p>",
    "<pre>public class Person {\n    private String name;\n    public void setName(String name) { this.name = name; }\n    public String getName() { return name; }\n}</pre>",

    "<h2>Inheritance (Kế thừa)</h2>",
    "<p>Class con kế thừa class cha bằng từ khóa <strong>extends</strong>, giúp tái sử dụng code.</p>",
    "<pre>class Animal {\n    void eat() { System.out.println(\"Eating...\"); }\n}\n\nclass Dog extends Animal {\n    void bark() { System.out.println(\"Woof!\"); }\n}\n\nDog d = new Dog();\nd.eat(); // từ class cha\n d.bark();</pre>",

    "<h2>Polymorphism (Đa hình)</h2>",
    "<p>Cho phép dùng một phương thức với nhiều dạng khác nhau, ví dụ <strong>overloading</strong> và <strong>overriding</strong>.</p>",
    "<pre>class Calculator {\n    int sum(int a, int b) { return a + b; }\n    double sum(double a, double b) { return a + b; }\n}</pre>",

    "<h2>Abstraction (Trừu tượng)</h2>",
    "<p>Ẩn chi tiết thực hiện, chỉ cung cấp giao diện. Dùng <strong>abstract class</strong> hoặc <strong>interface</strong>.</p>",
    "<pre>abstract class Shape {\n    abstract void draw();\n}\n\nclass Circle extends Shape {\n    void draw() { System.out.println(\"Drawing circle\"); }\n}</pre>",

    "<h2>Kết luận</h2>",
    "<p>Hiểu rõ OOP giúp bạn tổ chức code gọn gàng, dễ bảo trì và mở rộng. Các nguyên tắc chính cần nhớ: Class/Object, Encapsulation, Inheritance, Polymorphism và Abstraction.</p>"
  ]
},

{
  "title": "Exception Handling",
  "content": [
    "<h2>Giới thiệu</h2>",
    "<p>Trong Java, khi chương trình gặp lỗi trong quá trình chạy, gọi là <strong>exception</strong>. Exception Handling giúp chương trình không bị dừng đột ngột và xử lý lỗi một cách an toàn.</p>",

    "<h2>Try – Catch</h2>",
    "<p>Cấu trúc cơ bản để bắt lỗi:</p>",
    "<pre>try {\n    // đoạn code có thể gây lỗi\n    int result = 10 / 0;\n} catch (ArithmeticException e) {\n    System.out.println(\"Lỗi chia cho 0: \" + e.getMessage());\n}</pre>",

    "<h2>Finally</h2>",
    "<p>Khối <strong>finally</strong> luôn được thực hiện, dù có exception hay không:</p>",
    "<pre>try {\n    System.out.println(\"Thực hiện try\");\n} catch(Exception e) {\n    System.out.println(\"Có lỗi xảy ra\");\n} finally {\n    System.out.println(\"Luôn chạy finally\");\n}</pre>",

    "<h2>Throw và Throws</h2>",
    "<p>Dùng <strong>throw</strong> để ném 1 exception, <strong>throws</strong> để khai báo method có thể ném exception:</p>",
    "<pre>public void checkAge(int age) throws IllegalArgumentException {\n    if(age &lt; 18) {\n        throw new IllegalArgumentException(\"Tuổi phải từ 18 trở lên\");\n    }\n}\n\ntry {\n    checkAge(15);\n} catch(IllegalArgumentException e) {\n    System.out.println(e.getMessage());\n}</pre>",

    "<h2>Các loại Exception phổ biến</h2>",
    "<ul>",
    "<li>ArithmeticException – lỗi toán học (chia cho 0)</li>",
    "<li>NullPointerException – tham chiếu null</li>",
    "<li>ArrayIndexOutOfBoundsException – truy xuất mảng ngoài phạm vi</li>",
    "<li>IOException – lỗi input/output</li>",
    "</ul>",

    "<h2>Kết luận</h2>",
    "<p>Exception Handling giúp chương trình Java ổn định, tránh crash khi gặp lỗi. Các công cụ chính gồm <strong>try-catch-finally</strong>, <strong>throw</strong> và <strong>throws</strong>. Việc nắm rõ exception phổ biến giúp debug nhanh hơn và viết code an toàn hơn.</p>"
  ]
},

{
  "title": "Collections Framework",
  "content": [
    "<h2>Giới thiệu</h2>",
    "<p>Collections Framework trong Java cung cấp các cấu trúc dữ liệu như List, Set, Map để lưu trữ, truy xuất và xử lý dữ liệu một cách linh hoạt và hiệu quả. Đây là phần quan trọng để viết code gọn gàng và dễ bảo trì.</p>",

    "<h2>List</h2>",
    "<p>List là tập hợp các phần tử có thứ tự, có thể chứa trùng lặp.</p>",
    "<p>Ví dụ ArrayList:</p>",
    "<pre>import java.util.ArrayList;\n\nArrayList<String> names = new ArrayList<>();\nnames.add(\"Duy\");\nnames.add(\"An\");\nnames.add(\"Lan\");\nSystem.out.println(names.get(0)); // Duy</pre>",

    "<h2>Set</h2>",
    "<p>Set là tập hợp không có phần tử trùng lặp, không có thứ tự cố định.</p>",
    "<pre>import java.util.HashSet;\n\nHashSet<Integer> numbers = new HashSet<>();\nnumbers.add(10);\nnumbers.add(20);\nnumbers.add(10); // trùng sẽ bị bỏ qua\nSystem.out.println(numbers);</pre>",

    "<h2>Map</h2>",
    "<p>Map lưu trữ dữ liệu dưới dạng key-value, key là duy nhất.</p>",
    "<pre>import java.util.HashMap;\n\nHashMap<String, Integer> scores = new HashMap<>();\nscores.put(\"Duy\", 95);\nscores.put(\"An\", 88);\nSystem.out.println(scores.get(\"Duy\")); // 95</pre>",

    "<h2>Iterator</h2>",
    "<p>Iterator giúp duyệt qua các phần tử của Collection:</p>",
    "<pre>import java.util.ArrayList;\nimport java.util.Iterator;\n\nArrayList<String> list = new ArrayList<>();\nlist.add(\"A\");\nlist.add(\"B\");\nIterator<String> it = list.iterator();\nwhile(it.hasNext()) {\n    System.out.println(it.next());\n}</pre>",

    "<h2>Kết luận</h2>",
    "<p>Collections Framework là công cụ cực kỳ mạnh mẽ trong Java. Nắm rõ List, Set, Map và cách duyệt qua các phần tử giúp bạn xử lý dữ liệu nhanh chóng và viết code rõ ràng, dễ bảo trì.</p>"
  ]
},
{
  "title": "Streams API & Lambda – Map, Filter, Reduce, Lambda Expressions",
  "content": [
    "<h3>1. Streams API là gì?</h3>",
    "<p>Streams API trong Java (từ Java 8) cho phép thao tác dữ liệu theo kiểu lập trình hàm. Thay vì dùng vòng lặp truyền thống, bạn có thể dùng các phương thức như <code>map()</code>, <code>filter()</code>, <code>reduce()</code>...</p>",

    "<h3>2. Lambda Expressions</h3>",
    "<p>Lambda là cách viết hàm ngắn gọn, thường dùng với Streams. Ví dụ:</p>",
    "<pre><code>List&lt;Integer&gt; nums = Arrays.asList(1, 2, 3, 4, 5);\nnums.forEach(n -&gt; System.out.println(n));</code></pre>",

    "<h3>3. Map</h3>",
    "<p>Dùng để biến đổi từng phần tử:</p>",
    "<pre><code>List&lt;Integer&gt; squared = nums.stream()\n    .map(n -&gt; n * n)\n    .collect(Collectors.toList());</code></pre>",

    "<h3>4. Filter</h3>",
    "<p>Lọc dữ liệu dựa trên điều kiện:</p>",
    "<pre><code>List&lt;Integer&gt; even = nums.stream()\n    .filter(n -&gt; n % 2 == 0)\n    .collect(Collectors.toList());</code></pre>",

    "<h3>5. Reduce</h3>",
    "<p>Gộp dữ liệu thành một giá trị duy nhất:</p>",
    "<pre><code>int sum = nums.stream()\n    .reduce(0, (a, b) -&gt; a + b);</code></pre>",

    "<h3>6. Kết luận</h3>",
    "<p>Streams API kết hợp với Lambda expressions giúp code ngắn gọn, dễ đọc và dễ bảo trì hơn khi làm việc với collection dữ liệu trong Java.</p>"
  ]
}, 

{
  "title": "JS Basics – Biến, hàm, vòng lặp, object, array",
  "content": [
    "<h2>Giới thiệu</h2>",
    "<p>JavaScript (JS) là ngôn ngữ lập trình phổ biến để xây dựng website tương tác. Bài viết này giới thiệu các khái niệm cơ bản nhất: biến, hàm, vòng lặp, object và array.</p>",

    "<h2>Biến (Variables)</h2>",
    "<p>Dùng để lưu trữ dữ liệu. Có 3 cách khai báo: <code>var</code>, <code>let</code>, <code>const</code>.</p>",
    "<pre><code>let name = 'Duy';\nconst age = 20;\nvar city = 'HCM';</code></pre>",
    "<p><strong>let</strong> và <strong>const</strong> (ES6) được khuyến khích dùng thay cho <strong>var</strong>.</p>",

    "<h2>Hàm (Functions)</h2>",
    "<p>Hàm giúp tái sử dụng code.</p>",
    "<pre><code>function greet(name) {\n  return 'Hello ' + name;\n}\n\nconsole.log(greet('Duy'));</code></pre>",
    "<p>Arrow function:</p>",
    "<pre><code>const add = (a, b) => a + b;\nconsole.log(add(2, 3)); // 5</code></pre>",

    "<h2>Vòng lặp (Loops)</h2>",
    "<p>Dùng để lặp nhiều lần một đoạn code.</p>",
    "<pre><code>for(let i = 0; i < 5; i++) {\n  console.log(i);\n}</code></pre>",
    "<pre><code>let j = 0;\nwhile(j < 5) {\n  console.log(j);\n  j++;\n}</code></pre>",

    "<h2>Object</h2>",
    "<p>Object lưu trữ dữ liệu dạng key–value.</p>",
    "<pre><code>const person = {\n  name: 'Duy',\n  age: 20\n};\nconsole.log(person.name);</code></pre>",

    "<h2>Array</h2>",
    "<p>Array là danh sách phần tử, có thể chứa nhiều kiểu dữ liệu.</p>",
    "<pre><code>const numbers = [1, 2, 3, 4];\nconsole.log(numbers[0]); // 1</code></pre>",
    "<p>Một số hàm xử lý array phổ biến:</p>",
    "<pre><code>numbers.push(5); // thêm phần tử\nnumbers.pop(); // xóa phần tử cuối\nnumbers.forEach(n => console.log(n));</code></pre>",

    "<h2>Kết luận</h2>",
    "<p>Nắm vững các khái niệm cơ bản này sẽ giúp bạn dễ dàng học các chủ đề nâng cao hơn như DOM, event handling, async/await.</p>"
  ]
},

{
  "title": "DOM Manipulation – querySelector, innerHTML, event listeners",
  "content": [
    "<h2>Giới thiệu</h2>",
    "<p>DOM (Document Object Model) là cấu trúc dữ liệu dạng cây đại diện cho toàn bộ nội dung của một trang web. Mỗi thẻ HTML như <code>&lt;div&gt;</code>, <code>&lt;p&gt;</code>, hình ảnh hoặc nút bấm đều là một nút (node) trong cây DOM.</p>",
    "<p>Bằng cách sử dụng JavaScript, lập trình viên có thể truy cập và thay đổi cây DOM để cập nhật nội dung, thêm hoặc xóa phần tử, và phản hồi các hành động của người dùng mà không cần tải lại trang.</p>",

    "<h2>querySelector</h2>",
    "<p><code>querySelector()</code> cho phép chọn phần tử DOM đầu tiên khớp với bộ chọn CSS.</p>",
    "<pre><code>const title = document.querySelector('#main-title');\nconsole.log(title);\n\nconst firstParagraph = document.querySelector('.intro');\nconst button = document.querySelector('button');</code></pre>",
    "<p>Ta có thể chọn phần tử dựa vào <strong>id</strong>, <strong>class</strong> hoặc tên thẻ HTML.</p>",

    "<h2>Thay đổi nội dung với innerHTML và textContent</h2>",
    "<p>Sau khi đã chọn được phần tử DOM, có thể thay đổi nội dung bằng <code>textContent</code> hoặc <code>innerHTML</code>.</p>",
    "<pre><code>const title = document.querySelector('#main-title');\ntitle.textContent = 'Tiêu đề mới';</code></pre>",
    "<p><code>innerHTML</code> cho phép chèn thêm HTML bên trong phần tử:</p>",
    "<pre><code>const container = document.querySelector('#container');\ncontainer.innerHTML = '&lt;p&gt;Nội dung mới với &lt;strong&gt;HTML&lt;/strong&gt;&lt;/p&gt;';</code></pre>",

    "<h2>Event Listeners</h2>",
    "<p>Event listener cho phép lắng nghe và xử lý các sự kiện người dùng như click, nhập liệu, cuộn trang.</p>",
    "<pre><code>const button = document.querySelector('#myButton');\nbutton.addEventListener('click', function() {\n  alert('Bạn vừa nhấn nút!');\n});</code></pre>",
    "<p>Có thể dùng hàm mũi tên (arrow function):</p>",
    "<pre><code>button.addEventListener('click', () =&gt; {\n  console.log('Button clicked!');\n});</code></pre>",

    "<h2>Ví dụ kết hợp</h2>",
    "<pre><code>&lt;h1 id='main-title'&gt;Xin chào!&lt;/h1&gt;\n&lt;button id='changeBtn'&gt;Đổi tiêu đề&lt;/button&gt;\n&lt;script&gt;\n  const title = document.querySelector('#main-title');\n  const button = document.querySelector('#changeBtn');\n\n  button.addEventListener('click', () =&gt; {\n    title.textContent = 'Tiêu đề đã được thay đổi!';\n  });\n&lt;/script&gt;</code></pre>",
    "<p>Khi người dùng nhấn nút, nội dung tiêu đề sẽ thay đổi mà không cần tải lại trang.</p>",

    "<h2>Lợi ích của DOM Manipulation</h2>",
    "<ul>",
    "<li>Tạo giao diện người dùng động và tương tác.</li>",
    "<li>Cải thiện trải nghiệm người dùng nhờ phản hồi tức thì.</li>",
    "<li>Giúp cập nhật nội dung trang mà không cần tải lại toàn bộ.</li>",
    "</ul>",

    "<h2>Kết luận</h2>",
    "<p>DOM Manipulation là kỹ năng nền tảng cho lập trình viên front-end. Thành thạo <code>querySelector</code>, <code>innerHTML</code> và <code>event listeners</code> sẽ giúp bạn xây dựng các trang web linh hoạt và thân thiện với người dùng.</p>"
  ]
},

{
  "title": "ES6 Features – let/const, arrow functions, template literals, destructuring",
  "content": [
    "<h2>Giới thiệu</h2>",
    "<p>ECMAScript 2015 (ES6) là một bản nâng cấp lớn của JavaScript, mang lại nhiều cú pháp và tính năng mới, giúp code ngắn gọn, dễ đọc và hiện đại hơn. Các tính năng phổ biến nhất gồm: <strong>let/const</strong>, <strong>arrow functions</strong>, <strong>template literals</strong> và <strong>destructuring</strong>.</p>",

    "<h2>let và const</h2>",
    "<p>Trước ES6, JavaScript chỉ có <code>var</code> để khai báo biến. ES6 giới thiệu <code>let</code> và <code>const</code>, giúp quản lý phạm vi biến tốt hơn.</p>",
    "<pre><code>let x = 10;\nconst y = 20;\n\nx = 15; // Hợp lệ\n// y = 25; // Lỗi, vì y là hằng số</code></pre>",
    "<p><strong>let</strong> dùng để khai báo biến có thể thay đổi, <strong>const</strong> cho giá trị không thay đổi. Cả hai đều có phạm vi khối (block scope), an toàn hơn so với <strong>var</strong>.</p>",

    "<h2>Arrow Functions</h2>",
    "<p>Arrow function là cú pháp ngắn gọn hơn để viết hàm và tự động ràng buộc ngữ cảnh <code>this</code>.</p>",
    "<pre><code>// Cách viết cũ\nfunction add(a, b) {\n  return a + b;\n}\n\n// Arrow function\nconst add = (a, b) => a + b;\nconsole.log(add(2, 3)); // 5</code></pre>",
    "<p>Nếu hàm chỉ có một dòng trả về, có thể bỏ dấu <code>{}</code> và từ khóa <code>return</code>.</p>",

    "<h2>Template Literals</h2>",
    "<p>Template literals (chuỗi mẫu) sử dụng dấu backtick (<code>`</code>) cho phép chèn biến và biểu thức dễ dàng với cú pháp <code>${…}</code>.</p>",
    "<pre><code>const name = 'Duy';\nconst age = 20;\nconsole.log(`Tên tôi là ${name} và tôi ${age} tuổi.`);</code></pre>",
    "<p>Template literals cũng hỗ trợ viết chuỗi nhiều dòng:</p>",
    "<pre><code>const text = `Dòng 1\nDòng 2\nDòng 3`;\nconsole.log(text);</code></pre>",

    "<h2>Destructuring</h2>",
    "<p>Destructuring cho phép trích xuất giá trị từ mảng hoặc object một cách gọn gàng.</p>",
    "<pre><code>// Với mảng\nconst numbers = [1, 2, 3];\nconst [a, b, c] = numbers;\nconsole.log(a, b, c); // 1 2 3\n\n// Với object\nconst person = { name: 'Duy', age: 20 };\nconst { name, age } = person;\nconsole.log(name, age); // Duy 20</code></pre>",

    "<h2>Ví dụ kết hợp</h2>",
    "<pre><code>const students = [\n  { name: 'An', score: 8 },\n  { name: 'Bình', score: 9 }\n];\n\nstudents.forEach(({ name, score }) => {\n  console.log(`${name} đạt ${score} điểm`);\n});</code></pre>",
    "<p>Ví dụ trên kết hợp <strong>arrow functions</strong>, <strong>template literals</strong> và <strong>destructuring</strong> để viết code ngắn gọn và rõ ràng.</p>",

    "<h2>Kết luận</h2>",
    "<p>Việc làm chủ các tính năng ES6 sẽ giúp bạn viết code JavaScript hiện đại, dễ bảo trì và hiệu quả hơn. Đây là nền tảng quan trọng để tiếp cận các thư viện và framework như React, Vue hay Node.js.</p>"
  ]
},

{
  "title": "Async Programming – Callbacks, Promises, Async/Await, fetch API",
  "content": [
    "<h2>Giới thiệu</h2>",
    "<p>Lập trình bất đồng bộ (Asynchronous Programming) trong JavaScript cho phép xử lý các tác vụ mất thời gian (như gọi API, đọc file, truy vấn cơ sở dữ liệu) mà không chặn luồng chính của ứng dụng. Điều này giúp website hoạt động mượt mà và phản hồi tốt hơn.</p>",

    "<h2>Callbacks</h2>",
    "<p>Callback là một hàm được truyền vào hàm khác và sẽ được gọi sau khi tác vụ hoàn tất. Đây là cách tiếp cận truyền thống để xử lý bất đồng bộ.</p>",
    "<pre><code>function fetchData(callback) {\n  console.log('Đang tải dữ liệu...');\n  setTimeout(() => {\n    callback('Dữ liệu đã tải xong');\n  }, 2000);\n}\n\nfetchData(result => {\n  console.log(result);\n});</code></pre>",
    "<p>Nhược điểm của callbacks là dễ dẫn đến <strong>callback hell</strong> khi có nhiều tác vụ nối tiếp nhau.</p>",

    "<h2>Promises</h2>",
    "<p>Promise là một đối tượng đại diện cho kết quả của một thao tác bất đồng bộ (có thể hoàn thành hoặc thất bại). Promise giúp viết code dễ đọc và dễ quản lý hơn.</p>",
    "<pre><code>function fetchData() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve('Dữ liệu đã tải xong');\n    }, 2000);\n  });\n}\n\nfetchData()\n  .then(result => console.log(result))\n  .catch(error => console.error(error));</code></pre>",
    "<p>Phương thức <code>.then()</code> được gọi khi Promise thành công, <code>.catch()</code> xử lý lỗi.</p>",

    "<h2>Async/Await</h2>",
    "<p>Async/Await được giới thiệu từ ES2017 giúp code bất đồng bộ trông giống code đồng bộ, dễ đọc hơn.</p>",
    "<pre><code>function fetchData() {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve('Dữ liệu đã tải xong');\n    }, 2000);\n  });\n}\n\nasync function getData() {\n  console.log('Bắt đầu tải...');\n  const result = await fetchData();\n  console.log(result);\n}\n\ngetData();</code></pre>",
    "<p>Từ khóa <code>await</code> chỉ dùng bên trong hàm được khai báo với <code>async</code>, giúp dừng hàm cho đến khi Promise được giải quyết.</p>",

    "<h2>fetch API</h2>",
    "<p><code>fetch</code> là hàm tích hợp trong JavaScript dùng để gửi yêu cầu HTTP một cách dễ dàng và trả về một Promise.</p>",
    "<pre><code>async function fetchUsers() {\n  try {\n    const response = await fetch('https://jsonplaceholder.typicode.com/users');\n    const data = await response.json();\n    console.log(data);\n  } catch (error) {\n    console.error('Lỗi:', error);\n  }\n}\n\nfetchUsers();</code></pre>",
    "<p>Với <code>fetch</code> và <code>async/await</code>, ta có thể viết code gọi API ngắn gọn, rõ ràng và dễ bảo trì.</p>",

    "<h2>So sánh</h2>",
    "<ul>\n  <li><strong>Callbacks:</strong> Dễ hiểu nhưng nhanh chóng trở nên khó quản lý khi nhiều tác vụ nối tiếp.</li>\n  <li><strong>Promises:</strong> Tổ chức tốt hơn, tránh callback hell.</li>\n  <li><strong>Async/Await:</strong> Cú pháp gọn gàng, dễ đọc, đặc biệt hữu ích cho các tác vụ nối tiếp.</li>\n</ul>",

    "<h2>Kết luận</h2>",
    "<p>Hiểu và làm chủ các cơ chế bất đồng bộ là chìa khóa để xây dựng các ứng dụng web hiện đại, tối ưu trải nghiệm người dùng và hiệu năng hệ thống.</p>"
  ]
}




]
